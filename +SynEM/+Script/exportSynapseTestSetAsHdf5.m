% Written by
%   Alessandro Motta <alessandro.motta@brain.mpg.de>
clear;

%% Configuration
outDir = '/tmpscratch/amotta/l4/2019-10-22-synem-training-and-test-data-as-hdf5';

% NOTE(amotta): /mnt/mpibr/data/Data is //storage.hest.corp.brain.mpg.de/data
thesisRootDir = '/mnt/mpibr/data/Data/stafflerb/fromPersonal/data/SynEMv2/TestSet';
thesisDirs = {'Cube1082', 'Cube1579'};

% NOTE(amotta): The EM data we've provided with the training data has a
% padding of (100, 100, 40) in both the positive and negative direction
% around the box of interest. See +SynEM/+Script/exportSynapsesAsHdf5.m
thesisPaddingVx = [100, 100, 40];

thesisOutPrefix = '2012-09-28_ex145_07x2_ROI2017_TestSet';

l4Roi2017RootDir = '/gaba/u/mberning/results/pipeline/20170217_ROI';

info = Util.runInfo();
Util.showRunInfo(info);

%% Test set generated by Benedikt Staffler for his PhD thesis
curParam = fullfile(l4Roi2017RootDir, 'allParameter.mat');
curParam = Util.load(curParam, 'p');

for curThesisDirIdx = 2%1:numel(thesisDirs)
    curThesisDir = thesisDirs{curThesisDirIdx};
    curThesisDir = fullfile(thesisRootDir, curThesisDir);
    
    curLabels = load(fullfile(curThesisDir, 'labels.mat'));
    curSynapseIds = uint32(curLabels.interfaceLabels(:));
    
    curBox = curLabels.bbox;
    curBoxPadded = curBox + [-1, +1] .* thesisPaddingVx(:);
    
    curSiz = 1 + diff(curBox, 1, 2)';
    curSizPadded = 1 + diff(curBoxPadded, 1, 2)';
    
    curRaw = loadRawData(curParam.raw, curBoxPadded);
    curSeg = loadSegDataGlobal(curParam.seg, curBoxPadded);
    
    curCubeIds = curBox(:, 1) - curParam.bbox(:, 1) + 1;
    curCubeIds = ceil(curCubeIds ./ curParam.tileSize);
    
    curCubeId = num2cell(curCubeIds);
    curCubeId = sub2ind(size(curParam.local), curCubeId{:});
    curCubeParam = curParam.local(curCubeId);
    
    curEdges = Util.load(curCubeParam.edgeFile, 'edges');
    assert(isequal(size(curEdges, 1), numel(curLabels.interfaceLabels)));
    assert(issortedrows(curEdges));
    
    curBorders = Util.load(curCubeParam.borderFile, 'borders');
    assert(isequal(numel(curBorders), numel(curLabels.interfaceLabels)));
    
    % Extract voxel indices and convert to uint32
    curBorders = reshape({curBorders.PixelIdxList}, [], 1);
    
    % Add padding to borders
    for curBorderIdx = 1:numel(curBorders)        
        curIds = {curBorders{curBorderIdx}(:), [], []};
       [curIds{:}] = ind2sub(curSiz, curIds{1});
       
        for i = 1:3; curIds{i} = curIds{i} + thesisPaddingVx(i); end
        
        curIds = sub2ind(curSizPadded, curIds{:});
        curIds = reshape(uint32(curIds), [], 1);
        curBorders{curBorderIdx} = curIds;        
    end
    
    % Build output
    curOut = struct;
    curOut.em = curRaw;
    curOut.segmentation = curSeg;
    curOut.interfaces = curBorders;
    curOut.edges = curEdges;
    curOut.synapseIds = curSynapseIds;
    
%{
    % For debugging
    curMov = reshape(curOut.em, [1, size(curOut.em)]);
    curMov = reshape(repmat(curMov, 3, 1, 1, 1), 3, []);
    
    curSynVoxels = curOut.interfaces(curOut.synapseIds > 0);
    curSynVoxels = cell2mat(curSynVoxels);
    
    curMov(1, curSynVoxels) = intmax(class(curMov));
    curMov(2, curSynVoxels) = 0;
    curMov(3, curSynVoxels) = 0;
    
    curMov = reshape(curMov, [3, size(curOut.em)]);
    curMov = permute(curMov, [2, 3, 1, 4]);
    implay(curMov);
%}
    
    % Save output
   [~, curOutFile] = fileparts(curThesisDir);
    curOutFile = sprintf('%s_%s.hdf5', thesisOutPrefix, curOutFile);
    curOutFile = fullfile(outDir, curOutFile);
    
    structToHdf5(curOutFile, '/', curOut);
    infoToHdf5(curOutFile, info);
    Util.protect(curOutFile);
end
