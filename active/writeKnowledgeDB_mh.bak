function [settings, layer, missions] = writeKnowledgeDB_mh(parameter, seg, edges, p, edgesOld, pOld)

% Function to keep all parameter
kdbParameter = setKDBparameter();

% Normalize probability
p = p ./ max(p);

% Segmentation auswachsen
seg = imdilate(seg, ones(3,3,3));

% compute princomps
objProp = computePrincomps_fun(seg, kdbParameter.settings.voxelSize);

% Metadata fuer Tasks generieren
countMissions = 0;
cx_allmissionCount_final=0;
cutoffVoxelno = [10000 150000];
cutoffVoxelno_PossibleEnds = [5000 150000];
cutoffHeuristc = 40;
for i=1:size(edges,1) 
    idx1 = edges(i,1);
    idx2 = edges(i,2);  
    directionality = objProp(idx1).pc1Span/(2*(objProp(idx1).objSize/3*4/pi)^(1/3));
    voxelno = Princomps{cx_princompPointer(idx1)}.voxelno;  
    cx_allRelevantPrincomps{i} = Princomps{cx_princompPointer(idx1)};
    if (scoreHeuristic > cutoffHeuristc && voxelno > cutoffVoxelno(1) && voxelno < cutoffVoxelno(2) && ...
            Princomps{cx_princompPointer(idx2)}.voxelno>cutoffVoxelno_PossibleEnds(1) && Princomps{cx_princompPointer(idx2)}.voxelno<cutoffVoxelno_PossibleEnds(2))
        countMissions = countMissions + 1;
        % Determine CoM of border between objects (largest area of touch)
        border = bwdist(obj1) <= 1 & bwdist(obj2) <= 1;
        borderProp = regionprops(border, 'Centroid', 'Area');
        if size(borderProp,1) == 0
                error('No overlap');
        else
            %% RECOMPUTE PRINCOMP IN SPHERE AROUND CENTER OF CONTACT AREA, sphere radius ~50 vx (?)
            %% compute isosurface normal on contact area (either by fitting a plane explicitly or by isonormals and averaging over contact area voxels
            %% compoute alignment (scalar product) of princomp obj 1, princomp obj2, com line between 2 obj          
            %% check whether the coordinates are properly concatenated [x(..),y(..),z(..)] or [x(..)';y(..)';z(..)'] $$
            [x,y,z] = ind2sub(size(obj1),find(obj1));
            x=x*12;y=y*12;z=z*25;
            [~, idx] = max([borderProp(:).Area]);
            cx_contAreaCentroid = borderProp(idx).Centroid([2 1 3]).*[12 12 25];
            cx_acceptedObj1points = find( sum(([x(:),y(:),z(:)]-repmat(cx_contAreaCentroid,[length(x(:)) 1])).^2,2)<=500^2);
            [pcbasis_restr1{i},coord_in_new_basis_restr1{i},weights_restr1{i}] = princomp([x(cx_acceptedObj1points),y(cx_acceptedObj1points),z(cx_acceptedObj1points)]);
            sizeObj1_restricted{i} = length(cx_acceptedObj1points);
            [x,y,z] = ind2sub(size(obj1),find(obj2));x=x*12;y=y*12;z=z*25;
            cx_acceptedObj2points = find( sum(([x(:),y(:),z(:)]-repmat(cx_contAreaCentroid,[length(x(:)) 1])).^2,2)<=500^2);
            [pcbasis_restr2{i},coord_in_new_basis_restr2{i},weights_restr2{i}] = princomp([x(cx_acceptedObj2points),y(cx_acceptedObj2points),z(cx_acceptedObj2points)]);
            sizeObj2_restricted{i} = length(cx_acceptedObj2points);
            
            
           
            
            
            [~, idx] = max([borderProp(:).Area]); 
            counter.taskID = counter.taskID + 1;
            missions(i).missionId = counter.taskID;
            missions(i).errorCenter = round(borderProp(idx).Centroid([2 1 3])) + paramBG.bboxSmall(:,1)';
            missions(i).start.direction = obj2Prop.Centroid([2 1 3]) - obj1Prop.Centroid([2 1 3]);
            missions(i).start.direction = missions(i).start.direction / norm(missions(i).start.direction);
            missions(i).start.position = round(missions(i).errorCenter - 15 .* [1 1 0.5] .*  missions(i).start.direction);
            missions(i).start.id = idx1;
            [row, col] = find(edgesResort == idx1);
            col(col == 1) = 3;
            col = col - 1;
            
            countPEnds = 0;
            for k=1:length(row)
                
                voxelnoEnds = Princomps{cx_princompPointer(edgesResort(row(k),col(k)))}.voxelno;
                % take only objects with certain size
                if(voxelnoEnds > cutoffVoxelno_PossibleEnds(1) && voxelnoEnds < cutoffVoxelno_PossibleEnds(2))
                    countPEnds = countPEnds + 1;
                    missions(i).possibleEnds(countPEnds).id = edgesResort(row(k),col(k));
                    missions(i).possibleEnds(countPEnds).probability = pResort(row(k));
                    cx_allRelevantPrincomps_partners{i}{countPEnds} = Princomps{cx_princompPointer(edgesResort(row(k),col(k)))};
                end                             
            end
            
            %if there are no possibleEnds, set counter -1 so misson gets
            %overridden.. caution! last one is a problem!
%             if(countPEnds == 0)
%                 countMissions = countMissions - 1;
%             else
            if(countPEnds ~= 0)
                missions(i).difficulty = 1 - max([missions(i).possibleEnds(:).probability]);
                % next isosurface normal: %% INSERT FROM MARCEL's CODE $$$$
                % next isosurface normal:
                [cx_gridx,cx_gridy,cx_gridz] = meshgrid([1:size(border,1)],[1:size(border,2)],[1:size(border,3)]);
                cx_gridx=cx_gridx*12;cx_gridy=cx_gridy*12;cx_gridz=cx_gridz*12;
                iso_border = isosurface(cx_gridx,cx_gridy,cx_gridz,border,0.5);    % make isosurface
                ison_border = isonormals(cx_gridx,cx_gridy,cx_gridz,border,iso_border.vertices);   % get isonormals
                indneg = find(ison_border(:,1) < 0);    % find isonormals with negative x direction
                ison_border(indneg,:) = - ison_border(indneg,:);    % turn those opposite (to avoid opposite vectors to eliminate each other when averaging it
                indneg = find(sum(ison_border == 0 , 2)==2 & any(ison_border < 0,2)); % find vectors that are at one of the coordinate axes and that are negative
                ison_border(indneg,:) = - ison_border(indneg,:);    % turn those opposite so that they are in the positive part of the coordinate system
                ison_border = ison_border ./ repmat(sqrt(sum(ison_border.^2,2)),[1 3]); % make all isonormals length 1 that they have same weight
                border_isonormal_local = mean(ison_border,1);      % calculate average isonormal of the border area
                border_isonormal{i} = border_isonormal_local / norm(border_isonormal_local);   % make it length 1
                
                startID = missions(i).start.id;
                possendID=missions(i).possibleEnds(1).id;
                
                cx_pcapointertstart = find(cx_princomps.PCAmat(7,:)== startID);
                cx_pcapointertend = find(cx_princomps.PCAmat(7,:)== possendID);
                
%                 if and(~isempty(cx_pcapointertstart),~isempty(cx_pcapointertend))
                cx_objMeanstart = cx_princomps.cx_objMean(startID,:);        % is in nm!! but w/o bbox!!
                cx_objMeanend = cx_princomps.cx_objMean(possendID,:);
                cx_pairMean=(cx_objMeanstart+cx_objMeanend)/2;
                cx_errorCenter_scal = (missions(i).errorCenter-paramBG.bboxSmall(:,1)').*[12 12 25];
                cx_errorCenter_scal_offsetCorr = cx_errorCenter_scal([1 2 3]) - cx_pairMean;
                cx_thisContNormal = repmat(cx_errorCenter_scal_offsetCorr,[2 1]) + [0 0 0;(border_isonormal{i}([2 1 3]).*[12 12 25])*100];
                cx_axis3 = pcbasis_restr1{i}([1 2 3],1);
                cx_axis4 = pcbasis_restr2{i}([1 2 3],1);
                cx_allaxes = [cx_axis3';cx_axis4';(border_isonormal{i}([2 1 3]).*[12 12 25])];
                for cx_axi=1:size(cx_allaxes,1)
                    cx_allaxes(cx_axi,:) = cx_allaxes(cx_axi,:)/ norm(cx_allaxes(cx_axi,:));
                end
                cx_scalarProd_lin=[];
                for cx_axi=1:size(cx_allaxes,1)-1
                    for cx_axj=cx_axi+1:size(cx_allaxes,1)
                        cx_scalarProd(cx_axi,cx_axj) = dot(cx_allaxes(cx_axi,:),...
                            cx_allaxes(cx_axj,:));
                        cx_scalarProd_lin=[cx_scalarProd_lin,cx_scalarProd(cx_axi,cx_axj)];
                    end
                end
                cx_bestValAlignment = 1-prod(1-abs(cx_scalarProd_lin))
                cx_bestValAlignment2 = max(abs(cx_scalarProd_lin))
                [~,axid2]=max(abs(cx_scalarProd(:)));
                [axid1,axid2] = ind2sub(size(cx_scalarProd),axid2);
                if cx_scalarProd(axid1,axid2)>=0
                    cx_bestaxisever = mean(cx_allaxes([axid1,axid2],:));
                else
                    cx_bestaxisever = mean([cx_allaxes(axid1,:);-cx_allaxes(axid2,:)]);
                end
                
                if cx_bestValAlignment2>=0.8 && cx_bestValAlignment>=0.9                    
                    cx_dirTest = dot(missions(i).start.direction,(obj1Prop.Centroid([2 1 3])-borderProp(idx).Centroid([2 1 3])).*[12 12 25]);
                    cx_bestaxisever_forMission = cx_bestaxisever./[12 12 25];cx_bestaxisever_forMission=cx_bestaxisever_forMission/norm(cx_bestaxisever_forMission);
                    if cx_dirTest>0
                        cx_bestaxisever_forMission = -cx_bestaxisever_forMission;
                    end
                    missions(i).start.direction = cx_bestaxisever_forMission;
                    missions(i).start.position = round(missions(i).errorCenter - 30 .*  missions(i).start.direction);
                    cx_allmissionCount_final=cx_allmissionCount_final+1;
                else
                    missions(i).difficulty = nan;
                end
            else
                missions(i).difficulty = nan;
            end
        end
    else
        missions(i).difficulty = nan;
    end

end

% Load global counter variables
load(kdbParameter.counterLocation);

% Increase counter variables
if restartCounter
	counter.layerID = 1;
	counter.taskID = countMissons; 
else
	counter.layerID = counter.layerID + 1;
	counter.taskID = counter.taskID + countMissions;
end

% Save global counter variables
save(kdbParameter.counterLocation, 'counter');

% Create struct for layer.json
layer.type = 'segmentation';
layer.resolutions = 1;
layer.layerId = counter.layerID;
layer.bbox = paramBG.bboxBig;
layer.class = class(segBig);

% Define folder in which mission & layer json is placed (as well as segmentation in subfolder corresponding to resolution)
rootFolder = [kdbParameter.writeLocation kdbParameter.settings.name '/segmentation/layer' num2str(layer.layerId) '/'];

% Cubes schreiben
writeKnossosRoi([rootFolder '1/'], kdbParameter.settings.name, layer.bbox(:,1)', segBig, class(segBig));

% Write metadata to JSON
savejson('', kdbParameter.settings, [kdbParameter.writeLocation kdbParameter.settings.name '/settings.json']);
savejson('', layer, [rootFolder '/layer.json']);
savejson('', missions, [rootFolder '/missions.json']);

end

